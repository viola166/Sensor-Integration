// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from muse_file.djinni

#pragma once

#include <cstdint>
#include <memory>

namespace interaxon { namespace bridge {

class MuseConfiguration;
class MuseDataPacket;
class MuseFile;
class MuseVersion;
enum class MessageType;
struct AnnotationData;
struct ComputingDeviceConfiguration;
struct DspData;
struct MuseArtifactPacket;
struct Result;

/**
 * Reads a .muse file formatted according to the %Muse protobuf schema.
 * <p>
 * \classlink{MuseFileReader} is very similar to \classlink{ReaderMuse} as both classes
 * allow you to parse a file and generate data packets from it.  In most instances, \classlink{ReaderMuse}
 * is the better choice at it abstracts the details of the parsing of the file and allows you to handle
 * the data the same way that you would if you were connected to an actual \classlink{Muse}.  Use
 * \classlink{MuseFileReader} if you want finer control of the parsing of the file.
 * <p>
 * When the file reader is created it always starts reading from the beginning
 * of the file to the end.<br>
 *
 * <B>Threading:</B> It is NOT thread safe, you have to provide your own
 * synchronization mechanism if you plan to calls methods of this class from
 * different threads.
 * \if WINDOWS_ONLY
 * Make sure you do not call these methods from the main UI thread. Please use
 * an async task instead to avoid crashes.
 * \endif
 */
class MuseFileReader {
public:
    virtual ~MuseFileReader() {}

    /**
     * Returns an instance of file reader. Automatically opens a file. <br>
     * \return a \classlink{MuseFileReader} instance.
     */
    static std::shared_ptr<MuseFileReader> get_file_reader(const std::shared_ptr<MuseFile> & file);

    /**
     * Opens an existing file
     * Use this method if you explicitly closed file and want to open it again.
     * Calls \functionlink{MuseFile,open,open}.
     */
    virtual bool open() = 0;

    /**
     * Closes the file. Calls \functionlink{MuseFile,close,close}.
     * You don't have to call close explicitly unless you want to close file
     * immediately. close is called automatically, when the file reader object
     * is destroyed.
     */
    virtual bool close() = 0;

    /**
     * Reads the next message in the protobuf stream.<br>
     * \return The \classlink{Result} object with the status of the read operation.
     */
    virtual Result goto_next_message() = 0;

    /**
     * Returns the type of message at the current position in the file.
     * \return The type of message at the current position in the file.
     */
    virtual MessageType get_message_type() = 0;

    /**
     * Returns the id of the message at the current position in the file or
     * \c -1 if the id isn't found in the protobuf specification.
     * \return The id of the message at the current position in the file or
     * \c -1 if the id isn't found in the protobuf specification.
     */
    virtual int32_t get_message_id() = 0;

    /**
     * Returns the timestamp of the message at the current position in the file.
     * \return The timestamp of the message.
     */
    virtual int64_t get_message_timestamp() = 0;

    /**
     * Returns annotation data at the current position in the file.
     * \return The annotation data at the current position in the file.
     * \exception IncorrectMessageType If current message type is not
     * \enumlink{MessageType,ANNOTATION,IXNMessageTypeAnnotation}
     */
    virtual AnnotationData get_annotation() = 0;

    /**
     * Returns muse configuration data at the current position in the file.
     * \return The configuration data at the current position in the file.
     * \exception IncorrectMessageType If current message type is not
     * \enumlink{MessageType,CONFIGURATION,IXNMessageTypeConfiguration}
     */
    virtual std::shared_ptr<MuseConfiguration> get_configuration() = 0;

    /**
     * Returns muse version data at the current position in the file.
     * \return The version data at the current position in the file.
     * \exception IncorrectMessageType If current message type is not
     * \enumlink{MessageType,VERSION,IXNMessageTypeVersion}
     */
    virtual std::shared_ptr<MuseVersion> get_version() = 0;

    /**
     * Returns computing device configuration data at the current position in the file.
     * \return The device configuration data at the current position in the file.
     * \exception IncorrectMessageType If current message type is not
     * \enumlink{MessageType,COMPUTING_DEVICE,IXNMessageTypeComputingDevice}
     */
    virtual ComputingDeviceConfiguration get_computing_device_configuration() = 0;

    /**
     * Returns the dsp data at the current position in the file.
     * \return The dsp data at the current position in the file.
     * \exception IncorrectMessageType If current message type is not
     * \enumlink{MessageType,DSP,IXNMessageTypeDsp}
     */
    virtual DspData get_dsp() = 0;

    /**
     * Returns the muse data packet data at the current position in the file.
     * Use this method to get EEG, %Accelerometer, %Battery and Quantization packets.
     * \return The muse data packet data at the current position in the file.
     * \exception IncorrectMessageType If current message type is not one of:<br>
     * \enumlink{MessageType,ACCELEROMETER,IXNMessageTypeAccelerometer},<br>
     * \enumlink{MessageType,ACC_DROPPED,IXNMessageTypeAccDropped},<br>
     * \enumlink{MessageType,BATTERY,IXNMessageTypeBattery},<br>
     * \enumlink{MessageType,EEG,IXNMessageTypeEeg},<br>
     * \enumlink{MessageType,EEG_DROPPED,IXNMessageTypeEegDropped},<br>
     * \enumlink{MessageType,GYRO,IXNMessageTypeGyro},<br>
     * \enumlink{MessageType,MUSE_ELEMENTS,IXNMessageTypeMuseElements} or<br>
     * \enumlink{MessageType,QUANTIZATION,IXNMessageTypeQuantization}
     */
    virtual std::shared_ptr<MuseDataPacket> get_data_packet() = 0;

    /**
     * Returns the muse artifact packet data at the current position in the file.
     * \return The muse artifact packet at the current position in the file.
     * \exception IncorrectMessageType If current message type is not
     * \enumlink{MessageType,ARTIFACT,IXNMessageTypeArtifact},<br>
     */
    virtual MuseArtifactPacket get_artifact_packet() = 0;
};

} }  // namespace interaxon::bridge
