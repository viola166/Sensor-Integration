// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from sdk_bridge.djinni

#pragma once

#include <memory>
#include <unordered_set>

namespace interaxon { namespace bridge {

class EventLoop;
class MuseFileReader;
class ReaderMuse;
enum class MuseDataPacketType;
enum class MuseModel;
enum class ReaderMusePlaybackSettings;

/**
 * Builds a \classlink{ReaderMuse} that plays back the packets in the given
 * \classlink{MuseFileReader}.
 *
 * It exposes a way to set the configuration with chainable method calls, e.g.:
 * \if WINDOWS_ONLY
 * \code
 *     auto reader_muse = ReaderMuseBuilder::get()
 *         ->with_packet_types(my_packet_types)
 *         ->with_model(my_model)
 *         ->build(my_reader);
 * \endcode
 * \elseif ANDROID_ONLY
 * \code
 *     ReaderMuse muse = ReaderMuseBuilder.get()
 *         .withPacketTypes(myPacketTypes)
 *         .build(myMuseFileReader);
 * \endcode
 * \elseif IOS_ONLY
 * \code
 *     IXNReaderMuse *muse = [[[ReaderMuseBuilder get]
 *         withPacketTypes: myPacketTypes]
 *         build: myMuseFileReader];
 * \endcode
 * \else
 * MISSING_DOCUMENTATION
 * \endif
 */
class ReaderMuseBuilder {
public:
    virtual ~ReaderMuseBuilder() {}

    /**
     * Returns a reference to a \classlink{ReaderMuseBuilder}
     *
     * \return A reference to a \classlink{ReaderMuseBuilder}
     */
    static std::shared_ptr<ReaderMuseBuilder> get();

    /**
     * The set of packet types to pass through from the file.
     *
     * The default set contains the following all packet types in
     * \classlink{MuseDataPacketType}.
     * <br>
     *
     * The eventual set used is computed by the
     * last call to \inlinelink{withPacketTypes(),IXNReaderMuseBuilder::withPacketTypes:,with_packet_types()}
     *  minus the last call to \inlinelink{skipPacketTypes(),IXNReaderMuseBuilder::skipPacketTypes:,skip_packet_types()}
     *
     * \param types The set of packet types to read.
     * \return A reference to the same \classlink{ReaderMuseBuilder}
     */
    virtual std::shared_ptr<ReaderMuseBuilder> with_packet_types(const std::unordered_set<MuseDataPacketType> & types) = 0;

    /**
     * The set of packet types to explicitly ignore in the file.
     *
     * The default is the empty set.
     * <br>
     *
     * The eventual set used is computed by the
     * last call to \inlinelink{withPacketTypes(),IXNReaderMuseBuilder::withPacketTypes:,with_packet_types()}
     *  minus the last call to \inlinelink{skipPacketTypes(),IXNReaderMuseBuilder::skipPacketTypes:,skip_packet_types()}
     *
     * \param types The set of packet types to skip.
     * \return A reference to the same \classlink{ReaderMuseBuilder}
     */
    virtual std::shared_ptr<ReaderMuseBuilder> skip_packet_types(const std::unordered_set<MuseDataPacketType> & types) = 0;

    /**
     * The model that this Muse should say it is.
     *
     * The default is \muse2014.
     * \param model The model to use.
     * \return A reference to the same \classlink{ReaderMuseBuilder}
     */
    virtual std::shared_ptr<ReaderMuseBuilder> with_model(MuseModel model) = 0;

    /**
     * The playback settings to use with playing back the file.
     *
     * The default is
     * \enumlink{ReaderMusePlaybackSettings,AS_FAST_AS_POSSIBLE_WITH_SAVED_TIMESTAMP,IXNReaderMusePlaybackSettingsAsFastAsPossibleWithSavedTimestamp}
     *
     * \param settings The playback settings to use.
     *
     * \return A reference to the same \classlink{ReaderMuseBuilder}
     */
    virtual std::shared_ptr<ReaderMuseBuilder> with_playback_settings(ReaderMusePlaybackSettings settings) = 0;

    /**
     * The \classlink{EventLoop} to use to handle simulated playback.
     *
     * The default is a null pointer (no event loop).
     *
     * \param loop The \classlink{EventLoop} to use.
     *
     * \return A reference to the same \classlink{ReaderMuseBuilder}
     */
    virtual std::shared_ptr<ReaderMuseBuilder> with_event_loop(const std::shared_ptr<EventLoop> & loop) = 0;

    /**
     * Construct a \classlink{ReaderMuse}
     *
     * \param reader The \classlink{MuseFileReader} to use to read the file.
     * \return A \classlink{ReaderMuse} configured with the parameters that were set.
     */
    virtual std::shared_ptr<ReaderMuse> build(const std::shared_ptr<MuseFileReader> & reader) = 0;

    /**
     * Construct a \classlink{ReaderMuse}
     * \param reader The \classlink{MuseFileReader} to use to read the file.
     *
     * \if ANDROID_ONLY
     * \param asyncLoop The EventLoop to use for the call to Muse::runAsynchronously()
     * \elseif IOS_ONLY
     * \param asyncLoop The IXNEventLoop to use for the call to ::IXNMuse::runAsynchronously:
     * \elseif WINDOWS_ONLY
     * \param async_loop The EventLoop to use for the call to Muse::run_asynchronously()
     * \else
     * MISSING_DOCUMENTATION
     * \endif
     * \return A \classlink{ReaderMuse} configured with the parameters that were set.
     *
     * \deprecated Set the \classlink{EventLoop} with
     * \functionlink{ReaderMuseBuilder,withEventLoop,with_event_loop}
     * and then call \functionlink{ReaderMuseBuilder,build,build}
     * instead.
     */
    virtual std::shared_ptr<ReaderMuse> build_with_async(const std::shared_ptr<MuseFileReader> & reader, const std::shared_ptr<EventLoop> & async_loop) = 0;
};

} }  // namespace interaxon::bridge
